# Параллелизм и многопоточность
### Содержание
1. [Домашнее задание 7](#домашнее-задание-7)
2. [Домашнее задание 8](#домашнее-задание-8)
3. [Домашнее задание 9](#домашнее-заадние-9)
4. [Проект 4: Фрактальное пламя](#проект-4-фрактальное-пламя)

### Домашнее задание 7
##### Задание 1
Напишите программу, в которой несколько потоков увеличивают общий счетчик на 1.

Напишите тесты: убедитесь, что счетчик потокобезопасен и использует классы Atomic для исключения состояния гонки.

Решение: [../homework7/shared_counter/](../src/main/java/edu/homework7/shared_counter)

##### Задание 2
Реализуйте функцию, которая вычисляет факториал числа в многопоточном режиме при помощи `parallelStream`.

Решение: [../homework7/parallel_factorial/](../src/main/java/edu/homework7/parallel_factorial)

##### Задание 3
Мы пишем специальный кэширующий сервис для поиска людей по атрибутам:
```java
public record Person(int id, String name, String address, String phoneNumber) {}

interface PersonDatabase { 
    void add(Person person);
    void delete(int id);

    List<Person> findByName(String name);
    List<Person> findByAddress(String address);
    List<Person> findByPhone(String phone);
}
```

Сервис должен позволять найти человека только тогда, когда он стал доступен для поиска по любому из атрибутов, 
то есть невозможна ситуация, когда человека с `id=3` можно найти по имени, но нельзя по телефону.

Другими словами, человек появляется в поиске только тогда, тогда он доступен к поиску везде. Не может быть такого, 
что `FindByX` вернул что-то, а `FindByY` -- ничего.

Реализуйте задачу при помощи `synchronized`.

В общем случае можно воспринимать эту задачу как разработку некоторой in-memory базы ключ-значение с наличием 
обратных индексов.

Решение: [LockDatabase.java](../src/main/java/edu/homework7/person_database/LockDatabase.java)

##### Задание 3.5
В задачах кэширования часто есть дисбаланс между количеством чтений и записи.

Добавьте решение для предыдущей задачи на основе `ReadWriteLock`.

Решение: [Database.java](../src/main/java/edu/homework7/person_database/Database.java)

Вспомогательный класс: [Person.java](../src/main/java/edu/homework7/person_database/Person.java)

##### Задание 4
Реализуйте расчет числа Пи, используя метод Монте-Карло и несколько потоков.

Онлайн-демо: https://demonstrations.wolfram.com/ApproximatingPiByTheMonteCarloMethod.

Реализуйте сначала однопоточную версию, а затем многопоточную. Для оптимальной производительности используйте 
количество потоков равное количеству ядер компьютера.

В ответе текстом приведите среднее время ускорения решения в зависимости от количества потоков, а так же уровень 
погрешности для симуляции в 10млн, 100млн и 1млрд симуляций.

Однопоточный алгоритм решения задачи:
* Заведите переменные для подсчета общего числа точек `totalCount` и числа точек, попавших в круг `circleCount`
* Сделайте цикл на N итераций (значение конфигурируется), чем больше итераций вы сделаете, тем точнее будет приближение:
  * создайте случайную точку в квадрате
  * проверьте, находится ли точка внутри круга, и если это так, то увеличиваете `circleCount`
  * увеличиваете `totalCount`
* Вычислите приближение числа Пи как `4 * (circleCount / totalCount)`

В многопоточной версии пригодится класс `ThreadLocalRandom`: https://olka.github.io/blog/java_random_generators_perf/

Решение: [../homework7/pi_approximating/](../src/main/java/edu/homework7/pi_approximating)

### Домашнее задание 8
##### Задание 1
Дисклеймер: в Банке Тинькофф у разработчиков и менеджеров мир и любовь <3

Разработчика Ваню раздражает его менеджер и он хочет научиться едко отвечать ему в ответ. Для этого Ваня хочет 
разработать сервер, который будет выдавать известные цитаты по теме в ответ на ключевые слова.

Напишите такой сервер и Java-клиент для работы с ним:
* сервер и клиент должен работать на сырых сокетах
* используйте пул потоков -- сервер должен уметь принимать несколько соединений
* если максимальное количество одновременных соединений исчерпано, клиент должен ждать, пока не появится свободное соединение

Пример:
```
Ваня: личности
Сервер: Не переходи на личности там, где их нет

Ваня: оскорбления
Сервер: Если твои противники перешли на личные оскорбления, будь уверена — твоя победа не за горами

Ваня: глупый
Сервер: А я тебе говорил, что ты глупый? Так вот, я забираю свои слова обратно... Ты просто бог идиотизма.

Ваня: интеллект
Сервер: Чем ниже интеллект, тем громче оскорбления
```

Если возникнут сложности при работе с `ByteBuffer`, можете попробовать использовать `ObjectOutputStream`.

Решение: [../homework8/client_server_cyberbullying/](../src/main/java/edu/homework8/client_server_cyberbullying)

##### Задание 2
Реализуйте свой собственный интерфейс `ThreadPool`:
```java
public interface ThreadPool extends AutoCloseable { 
    void start();
    void execute(Runnable runnable);
}
```

Реализуйте имплементацию `FixedThreadPool`, фабричный метод `create` принимает на вход количество потоков. Внутри 
класса должны использоваться "голые" потоки - `Thread[]`.

Продемонстрируйте работоспособность на примере параллельного вычисления чисел Фибоначчи.

Решение: [../homework8/thread_pool/](../src/main/java/edu/homework8/thread_pool)

##### Задание 3 (бонусное, +1 балл)
В этом задании вы будете играть роль хакера, проникшего на сервер крупной компании. Вы успешно извлекли базу данных 
паролей, состоящую из строк следующего вида:
```
a.v.petrov  e10adc3949ba59abbe56e057f20f883e
v.v.belov   d8578edf8458ce06fbc5bb76a58c5ca4
a.s.ivanov  482c811da5d5b4bc6d497ffa98491e38
k.p.maslov  5f4dcc3b5aa765d61d8327deb882cf99
```

С помощью социальной инженерии вы узнали, что пароли захэшированы функцией MD5 и состоят только из букв латинского 
алфавита и цифр.

Ваша задача написать многопоточный перебиратор паролей.

Реализуйте сначала однопоточную версию, а затем многопоточную. 

В ответе текстом приведите среднее время ускорения решения в зависимости от количества потоков.

Не используйте пароли длиной больше 4-6 символов, иначе перебор будет слишком долгим.

Пример однопоточного алгоритма:
* Считайте базу паролей в словарь, где ключ - это хеш, а значение - имя пользователя
* Создайте функцию nextPassword, возвращающую следующий возможный пароль:
  * для сгенерированного пароля вычислите MD5 хэш
  * если вычисленный MD5 хэш присутствует в словаре, сохраните пароль и соответствующее имя пользователя
* Пока в словаре остаются хеши, продолжайте генерацию паролей
* В конце работы программы выведите словарь, где ключ - имя пользователя, а значение - найденный пароль

### Домашнее заадние 9
##### Задание 1
Создайте многопоточную систему сбора статистики.

Много потоков передают численные данные, а другие потоки агрегируют эти данные: считают сумму, среднее, 
максимум, минимум.

Пример:
```java
StatsCollector collector = ...;

collector.push("metric_name", new double[] {0.1, 0.05, 1.4, 5.1, 0.3});

for (var metric: collector.stats()) {
    // ...
}
```

Решение: [../homework9/stats_collector/](../src/main/java/edu/homework9/stats_collector)

##### Задание 2
Мы хотим написать параллельную функцию обработки дерева. Чтобы не быть слишком абстрактными, допустим, что дерево - 
это файловая система.

Реализуйте 2 алгоритма:
* поиск директорий, в которых больше 1000 файлов
* поиск файлов по предикату: размер, расширение

Для параллелизации используйте `ForkJoin` и `RecursiveTask`.

Решение: [../homework9/tree_analytics/](../src/main/java/edu/homework9/tree_analytics)

##### Задание 3
Модифицируете алгоритм поиска пути в лабиринте из Проекта 2, чтобы он мог использовать несколько потоков.

Если вы не делали это задание, то реализуйте многопоточный поиск в глубину.

Решение: [DepthFirstSearchParallelSolver.java](../src/main/java/edu/project2/solvers/DepthFirstSearchParallelSolver.java)

### Проект 4: Фрактальное пламя
Подробное описание проекта можно посмотреть [тут](./project4.md).

Справочная информация:
* Фрактальное пламя:
  * https://en.wikipedia.org/wiki/Fractal_flame
  * https://habr.com/ru/articles/251537
* Оригинальная статья (+ каталог вариаций): https://flam3.com/flame_draves.pdf
* Chaos Game:
  * https://en.wikipedia.org/wiki/Chaos_game
  * https://beltoforion.de/en/recreational_mathematics/chaos_game.php
* Описание СИФ с нуля: https://proproprogs.ru/fractals
* Онлайн демо: https://tariqksoliman.github.io/Fractal-Inferno

В этом задании ваша задача реализовать многопоточный генератор фрактального пламени.

Более крутые примеры: https://www.chaoticafractals.com/art/chaosfissure.

В основе алгоритма генерации фрактального пламени лежит `Chaos Game` (см оригинальную статью):
* Случайным образом выбирается пиксель `(x,y)`
* Производится достаточное количество итераций:
  * случайно выбирается вариация `fi(x,y)` из заранее заданного списка
  * `(x,y) := fi(x,y)`
  * увеличиваем счётчик "попаданий" в пиксель `(x,y) (hit count)`

Ваша задача реализовать этот алгоритм и сделать его многопоточным.

Совет: сначала сделайте функцию однопоточной, и после того, как все будет работать, делайте её многопоточной.

Ваша функция отрисовки должна принимать все конфигурируемые параметры как аргументы, например, размер изображения 
или коэффициенты трансформаций.

В результатах работы приведите примеры сравнения скорости работы однопоточной и многопоточной версии.

Оценка:
* Всего за проект можно получить 8 баллов
* +1 бонусный балл, если реализуете поддержку цветных изображений
* +1 бонусный балл, если реализуете поддержку логарифмической гамма-коррекции
* +1 бонусный балл, если вы добавите поддержку параметра симметрии
* +1 бонусный балл, если вы поделитесь вашим результатом в чате группы и вам поставят лайк

Решение: [../project4/](../src/main/java/edu/project4)
